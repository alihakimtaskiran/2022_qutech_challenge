{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b76871f6",
   "metadata": {},
   "outputs": [],
   "source": [
    "from qiskit import *\n",
    "from quantuminspire.qiskit import QI\n",
    "from getpass import getpass\n",
    "import json\n",
    "import smtplib\n",
    "from email.mime.multipart import MIMEMultipart\n",
    "from email.mime.text import MIMEText\n",
    "from email.mime.base import MIMEBase\n",
    "from email import encoders\n",
    "\n",
    "\n",
    "email = \"quantum_inpsire_account_email\"\n",
    "password = \"quantum_inpsire_account_email\"\n",
    "authentication = email, password\n",
    "QI.set_authentication_details(*authentication)\n",
    "QI.backends()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0242fe6b",
   "metadata": {},
   "outputs": [],
   "source": [
    "class Interface:\n",
    "    \n",
    "    bits = []  # stores Alice's bits\n",
    "    alices_bases = [] # stores Alice's bases\n",
    "    bobs_bases = [] # stores Bob's bases\n",
    "    qcs = [] # stores the quantum circuits for each bit \n",
    "    alices_measurement = \"\"\n",
    "    bobs_measurement = \"\"\n",
    "    qi_backend = QI.get_backend(\"Starmon-5\")\n",
    "\n",
    "    # read the bits chosen by Alice\n",
    "    def read_alices_file(self):\n",
    "        file = open(\"alice.txt\")\n",
    "        \n",
    "        while True:\n",
    "            bit = file.read(1)\n",
    "            basis = file.read(1)\n",
    "\n",
    "            # End of file\n",
    "            if not bit or not basis:\n",
    "                break\n",
    "            \n",
    "            self.bits.append(bit)\n",
    "            self.alices_bases.append(basis)\n",
    "\n",
    "\n",
    "    def read_bobs_file(self):\n",
    "        file = open(\"bob.txt\")\n",
    "        \n",
    "        while True:\n",
    "            basis = file.read(1)\n",
    "\n",
    "            if not basis:\n",
    "                break\n",
    "\n",
    "            self.bobs_bases.append(basis)\n",
    "\n",
    "\n",
    "    def measure_alice(self):\n",
    "        for i,bit in enumerate(self.bits):\n",
    "            qc = QuantumCircuit(1)\n",
    "            \n",
    "            # Encode bit 1 to state |1>\n",
    "            if bit == \"1\":\n",
    "                qc.x(0)\n",
    "            \n",
    "            # Measuring in X basis\n",
    "            if self.alices_bases[i]==\"X\":\n",
    "                qc.h(0)\n",
    "                \n",
    "            self.qcs.append(qc.copy()) # store Alice's encoding for Bob to measure\n",
    "            \n",
    "            # get the measurement for Alice\n",
    "            qc.measure_all()\n",
    "            \n",
    "            counts = execute(qc, self.qi_backend, shots=256).result().get_counts()\n",
    "            print(counts)\n",
    "            \n",
    "            self.alices_measurement += json.dumps(counts)\n",
    "            self.alices_measurement += \"\\n\"\n",
    "\n",
    "\n",
    "    def measure_bob(self):\n",
    "        for i in range(len(self.qcs)):\n",
    "                       \n",
    "            qc = self.qcs[i]\n",
    "                       \n",
    "            if self.bobs_bases[i] == \"X\":\n",
    "                qc.h(0)\n",
    "                qc.x(0)\n",
    "                       \n",
    "            # get the measurement for Bob\n",
    "            qc.measure_all()\n",
    "            \n",
    "            counts = execute(qc, self.qi_backend, shots=256).result().get_counts()\n",
    "            print(counts)\n",
    "            \n",
    "            self.bobs_measurement += json.dumps(counts) \n",
    "            self.bobs_measurement += \"\\n\"\n",
    "            \n",
    "                       \n",
    "    def run_alice(self):\n",
    "        self.read_alices_file()\n",
    "        self.measure_alice()\n",
    "        \n",
    "        with open(\"alices_results.txt\",\"w\") as f:\n",
    "            f.write(self.alices_measurement)\n",
    "            \n",
    "        send_email(\"phononsinterface@gmail.com\", <password>, toaddr, \"alices_results.txt\", \n",
    "                  <path to alices_results.txt>);\n",
    "            \n",
    "   \n",
    "    def run_bob(self):\n",
    "        self.read_bobs_file()\n",
    "        self.measure_bob()\n",
    "            \n",
    "        with open(\"bobs_results.txt\",\"w\") as f:\n",
    "            f.write(self.bobs_measurement)\n",
    "        \n",
    "        send_email(\"phononsinterface@gmail.com\", <password>, toaddr, \"bobs_results.txt\", \n",
    "                  <path to bobs_results.txt>);\n",
    "        \n",
    "\n",
    "    def send_email(fromaddr, password, toaddr, filename, filepath):\n",
    "\n",
    "        # instance of MIMEMultipart\n",
    "        msg = MIMEMultipart()\n",
    "\n",
    "        # storing the senders email address  \n",
    "        msg['From'] = fromaddr\n",
    "\n",
    "        # storing the receivers email address \n",
    "        msg['To'] = toaddr\n",
    "\n",
    "        # storing the subject \n",
    "        msg['Subject'] = \"Measurement results\"\n",
    "\n",
    "        # string to store the body of the mail\n",
    "        body = \" \"\n",
    "\n",
    "        # attach the body with the msg instance\n",
    "        msg.attach(MIMEText(body, 'plain'))\n",
    "\n",
    "        # open the file to be sent \n",
    "        attachment = open(filepath, \"rb\")\n",
    "\n",
    "        # instance of MIMEBase and named as p\n",
    "        p = MIMEBase('application', 'octet-stream')\n",
    "\n",
    "        # To change the payload into encoded form\n",
    "        p.set_payload((attachment).read())\n",
    "\n",
    "        # encode into base64\n",
    "        encoders.encode_base64(p)\n",
    "\n",
    "        p.add_header('Content-Disposition', \"attachment; filename= %s\" % filename)\n",
    "\n",
    "        # attach the instance 'p' to instance 'msg'\n",
    "        msg.attach(p)\n",
    "\n",
    "        # creates SMTP session\n",
    "        s = smtplib.SMTP('smtp.gmail.com', 587)\n",
    "\n",
    "        # start TLS for security\n",
    "        s.starttls()\n",
    "\n",
    "        # Authentication\n",
    "        s.login(fromaddr, password) # generate an app password from your gmail accounts (under settings->security)\n",
    "\n",
    "        # Converts the Multipart msg into a string\n",
    "        text = msg.as_string()\n",
    "\n",
    "        # sending the mail\n",
    "        s.sendmail(fromaddr, toaddr, text)\n",
    "\n",
    "        # terminating the session\n",
    "        s.quit()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fdae31b3",
   "metadata": {},
   "outputs": [],
   "source": [
    "interface = Interface()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "965ede72",
   "metadata": {},
   "outputs": [],
   "source": [
    "interface.run_alice()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "acccebb6",
   "metadata": {},
   "outputs": [],
   "source": [
    "interface.run_bob()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
